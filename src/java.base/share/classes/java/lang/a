27a28,29
> import java.lang.invoke.MethodHandles;
> import java.lang.invoke.VarHandle;
33a36,37
> import java.security.ProtectionDomain;
> import java.time.Duration;
35a40
> import java.util.Objects;
37a43,44
> import java.util.concurrent.Executor;
> import java.util.concurrent.ThreadFactory;
41a49,50
> import jdk.internal.misc.Unsafe;
> import jdk.internal.misc.VM;
46a56,59
> import jdk.internal.event.ThreadSleepEvent;
> 
> import static java.util.concurrent.TimeUnit.MILLISECONDS;
> import static java.util.concurrent.TimeUnit.NANOSECONDS;
50c63
<  * Virtual Machine allows an application to have multiple threads of
---
>  * virtual machine allows an application to have multiple threads of
52,87d64
<  * <p>
<  * Every thread has a priority. Threads with higher priority are
<  * executed in preference to threads with lower priority. Each thread
<  * may or may not also be marked as a daemon. When code running in
<  * some thread creates a new {@code Thread} object, the new
<  * thread has its priority initially set equal to the priority of the
<  * creating thread, and is a daemon thread if and only if the
<  * creating thread is a daemon.
<  * <p>
<  * When a Java Virtual Machine starts up, there is usually a single
<  * non-daemon thread (which typically calls the method named
<  * {@code main} of some designated class). The Java Virtual
<  * Machine continues to execute threads until either of the following
<  * occurs:
<  * <ul>
<  * <li>The {@code exit} method of class {@code Runtime} has been
<  *     called and the security manager has permitted the exit operation
<  *     to take place.
<  * <li>All threads that are not daemon threads have died, either by
<  *     returning from the call to the {@code run} method or by
<  *     throwing an exception that propagates beyond the {@code run}
<  *     method.
<  * </ul>
<  * <p>
<  * There are two ways to create a new thread of execution. One is to
<  * declare a class to be a subclass of {@code Thread}. This
<  * subclass should override the {@code run} method of class
<  * {@code Thread}. An instance of the subclass can then be
<  * allocated and started. For example, a thread that computes primes
<  * larger than a stated value could be written as follows:
<  * <hr><blockquote><pre>
<  *     class PrimeThread extends Thread {
<  *         long minPrime;
<  *         PrimeThread(long minPrime) {
<  *             this.minPrime = minPrime;
<  *         }
89,113c66,101
<  *         public void run() {
<  *             // compute primes larger than minPrime
<  *             &nbsp;.&nbsp;.&nbsp;.
<  *         }
<  *     }
<  * </pre></blockquote><hr>
<  * <p>
<  * The following code would then create a thread and start it running:
<  * <blockquote><pre>
<  *     PrimeThread p = new PrimeThread(143);
<  *     p.start();
<  * </pre></blockquote>
<  * <p>
<  * The other way to create a thread is to declare a class that
<  * implements the {@code Runnable} interface. That class then
<  * implements the {@code run} method. An instance of the class can
<  * then be allocated, passed as an argument when creating
<  * {@code Thread}, and started. The same example in this other
<  * style looks like the following:
<  * <hr><blockquote><pre>
<  *     class PrimeRun implements Runnable {
<  *         long minPrime;
<  *         PrimeRun(long minPrime) {
<  *             this.minPrime = minPrime;
<  *         }
---
>  * <p> {@code Thread} supports the creation of threads that are scheduled by the
>  * operating system. These threads are sometimes known as <i>kernel threads</i>
>  * or <i>heavyweight threads</i> and will usually have a large stack and other
>  * resources that are maintained by the operating system. Kernel threads are
>  * suitable for executing all types of tasks but they are a limited resource.
>  *
>  * <a id="virtual-threads"></a>
>  * <p> {@code Thread} also supports the creation of <i>virtual threads</i> that
>  * are scheduled by the Java virtual machine using a small set of kernel threads
>  * that are used as <em>carrier threads</em>.
>  * Virtual threads will typically require few resources and a single Java virtual
>  * machine may support millions of virtual threads. Virtual threads are suitable
>  * for executing tasks that spend most of the time blocked, often waiting for
>  * synchronous blocking I/O operations to complete.
>  * Locking and I/O operations are the <i>scheduling points</i> where a carrier thread
>  * is re-scheduled from one virtual thread to another. Code executing in virtual
>  * threads will usually not be aware of the underlying carrier thread, and in
>  * particular, the {@linkplain Thread#currentThread()} method, to obtain a reference
>  * to the <i>current thread</i>, will return the {@code Thread} object for the virtual
>  * thread.
>  *
>  * <p> {@code Thread} defines factory methods, and a {@linkplain Builder} API,
>  * for creating kernel or virtual threads. It also defines (for compatibility and
>  * customization reasons) constructors for creating kernel threads. Newer code
>  * is encouraged to use the factory methods or the builder rather than the constructors.
>  *
>  * <p> Kernel threads are designated <i>daemon</i> or <i>non-daemon</i> threads.
>  * When the Java virtual machine starts up, there is usually one non-daemon
>  * thread (the thread that typically calls the applications's {@code main} method).
>  * The Java virtual machine terminates when all started non-daemon threads have
>  * terminated. Unstarted daemon threads do not prevent the Java virtual machine from
>  * termination. The Java virtual machine can also be terminated by invoking the
>  * {@linkplain Runtime#exit(int)} method, in which case it will terminate even
>  * if there are non-daemon threads still running. The daemon status of virtual
>  * threads is meaningless and have no influence on when the Java virtual
>  * machine terminates.
115,132c103
<  *         public void run() {
<  *             // compute primes larger than minPrime
<  *             &nbsp;.&nbsp;.&nbsp;.
<  *         }
<  *     }
<  * </pre></blockquote><hr>
<  * <p>
<  * The following code would then create a thread and start it running:
<  * <blockquote><pre>
<  *     PrimeRun p = new PrimeRun(143);
<  *     new Thread(p).start();
<  * </pre></blockquote>
<  * <p>
<  * Every thread has a name for identification purposes. More than
<  * one thread may have the same name. If a name is not specified when
<  * a thread is created, a new name is generated for it.
<  * <p>
<  * Unless otherwise noted, passing a {@code null} argument to a constructor
---
>  * <p> Unless otherwise specified, passing a {@code null} argument to a constructor
137d107
<  * @see     Runnable
139,140d108
<  * @see     #run()
<  * @see     #stop()
150,160c118
<     private volatile String name;
<     private int priority;
< 
<     /* Whether or not the thread is a daemon thread. */
<     private boolean daemon = false;
< 
<     /* Interrupt state of the thread - read/written directly by JVM */
<     private volatile boolean interrupted;
< 
<     /* Fields reserved for exclusive use by the JVM */
<     private boolean stillborn = false;
---
>     /* Reserved for exclusive use by the JVM, TBD: move to FieldHolder */
163,164c121,146
<     /* What will be run. */
<     private Runnable target;
---
>     // holds fields for kernel threads
>     private static class FieldHolder {
>         final ThreadGroup group;
>         final Runnable task;
>         final long stackSize;
>         int priority;
>         boolean daemon;
>         volatile int threadStatus;
>         boolean stillborn;
> 
>         FieldHolder(ThreadGroup group,
>                     Runnable task,
>                     long stackSize,
>                     int priority,
>                     boolean daemon) {
>             this.group = group;
>             this.task = task;
>             this.stackSize = stackSize;
>             this.priority = priority;
>             this.daemon = daemon;
>         }
>     }
>     private final FieldHolder holder;
>     
>     // interrupt status (read/written by VM)
>     volatile boolean interrupted;
166,167c148,152
<     /* The group of this thread */
<     private ThreadGroup group;
---
>     // thread name
>     private volatile String name;
> 
>     // thread id
>     private final long tid;
169c154
<     /* The context ClassLoader for this thread */
---
>     // context ClassLoader
172c157
<     /* The inherited AccessControlContext of this thread */
---
>     // inherited AccessControlContext, TBD: move this to FieldHolder
191,207c176,189
<     /*
<      * The requested stack size for this thread, or 0 if the creator did
<      * not specify a stack size.  It is up to the VM to do whatever it
<      * likes with this number; some VMs will ignore it.
<      */
<     private final long stackSize;
< 
<     /*
<      * Thread ID
<      */
<     private final long tid;
< 
<     /* For generating thread ID */
<     private static long threadSeqNumber;
< 
<     private static synchronized long nextThreadID() {
<         return ++threadSeqNumber;
---
>     /**
>      * Helper class to generate unique thread identifiers. The identifiers start
>      * at 2 as this class cannot be used during early startup to generate the
>      * identifier for the primordial thread.
>      */
>     private static class ThreadIdentifiers {
>         private static final Unsafe U = Unsafe.getUnsafe();
>         private static final long NEXT_TID_OFFSET =
>             U.objectFieldOffset(ThreadIdentifiers.class, "nextTid");
>         private static final long TID_MASK = (1L << 48) - 1; 
>         private static volatile long nextTid = 2;
>         private static long next() {
>             return U.getAndAddLong(ThreadIdentifiers.class, NEXT_TID_OFFSET, 1);
>         }
211c193
<      * Java thread status for tools, default indicates thread 'not yet started'
---
>      * Lock object for thread interrupt.
213c195
<     private volatile int threadStatus;
---
>     final Object interruptLock = new Object();
221c203
<     volatile Object parkBlocker;
---
>     private volatile Object parkBlocker;
227,228c209
<     private volatile Interruptible blocker;
<     private final Object blockerLock = new Object();
---
>     volatile Interruptible nioBlocker;
235,236c216,217
<         synchronized (me.blockerLock) {
<             me.blocker = b;
---
>         synchronized (me.interruptLock) {
>             me.nioBlocker = b;
254a236,238
>     // current inner-most continuation
>     private Continuation cont;
> 
256,258c240,247
<      * Returns a reference to the currently executing thread object.
<      *
<      * @return  the currently executing thread.
---
>      * Sets the Thread object to be returned by Thread.currentThread().
>      */
>     @HotSpotIntrinsicCandidate
>     native void setCurrentThread(Thread thread);
> 
>     /**
>      * Returns the Thread object for the current thread.
>      * @return  the current thread
263a253,299
>      * Returns the current carrier thread.
>      */
>     static Thread currentCarrierThread() {
>         return currentThread0();
>     }
> 
>     @HotSpotIntrinsicCandidate
>     private static native Thread currentThread0();
> 
>     // Scoped support:
> 
>     /**
>      * TBD
>      * @return TBD
>      */
>     @HotSpotIntrinsicCandidate
>     static native Object[] scopedCache();
> 
>     @HotSpotIntrinsicCandidate
>     static native void setScopedCache(Object[] cache);
> 
>     // A simple (not very) random string of bits to use when evicting
>     // cache entries.
>     int victims
>         = 0b1100_1001_0000_1111_1101_1010_1010_0010;
> 
>     // V2:
>     private ScopedMap scopedMap;
> 
>     final ScopedMap scopedMap() {
>         if (Lifetime.version == Lifetime.Version.V1) {
>             return currentLifetime().scopedMap();
>         } else {
>             if (this.scopedMap == null) {
>                 this.scopedMap = new ScopedMap();
>             }
>             return this.scopedMap;
>         }
>     }
> 
>     final ScopedMap scopedMapOrNull () {
>         return this.scopedMap;
>     }
> 
>     // end Scoped support
> 
>     /**
279c315,323
<     public static native void yield();
---
>     public static void yield() {
>         Thread thread = currentThread();
>         if (thread.isVirtual()) {
>             ((VirtualThread) thread).tryYield();
>         } else {
>             yield0();
>         }
>     }
>     private static native void yield0();
298c342,370
<     public static native void sleep(long millis) throws InterruptedException;
---
>     public static void sleep(long millis) throws InterruptedException {
>         if (millis < 0) {
>             throw new IllegalArgumentException("timeout value is negative");
>         }
>         if (ThreadSleepEvent.isTurnedOn()) {
>             ThreadSleepEvent event = new ThreadSleepEvent();
>             try {
>                 event.time = NANOSECONDS.convert(millis, MILLISECONDS);
>                 event.begin();
>                 sleepMillis(millis);
>             } finally {
>                 event.commit();
>             }
>         } else {
>             sleepMillis(millis);
>         }
>     }
> 
>     private static void sleepMillis(long millis) throws InterruptedException {
>         Thread thread = currentThread();
>         if (thread.isVirtual()) {
>             long nanos = NANOSECONDS.convert(millis, MILLISECONDS);
>             ((VirtualThread) thread).sleepNanos(nanos);
>         } else {
>             sleep0(millis);
>         }
>     }
> 
>     private static native void sleep0(long millis) throws InterruptedException;
322,323c394
<     public static void sleep(long millis, int nanos)
<     throws InterruptedException {
---
>     public static void sleep(long millis, int nanos) throws InterruptedException {
330c401
<                                 "nanosecond timeout value out of range");
---
>                     "nanosecond timeout value out of range");
340a412,457
>      * Causes the currently executing thread to sleep (temporarily cease
>      * execution) for the specified duration, subject to the precision and
>      * accuracy of system timers and schedulers. This method is a no-op if
>      * the duration is less than zero.
>      *
>      * @param  duration
>      *         the duration to sleep
>      *
>      * @throws  InterruptedException
>      *          if the current thread is interrupted while sleeping. The
>      *          <i>interrupted status</i> of the current thread is
>      *          cleared when this exception is thrown.
>      * @throws  NullPointerException
>      *          if duration is null
>      *
>      * @since 99
>      */
>     public static void sleep(Duration duration) throws InterruptedException {
>         long nanos = duration.toNanos();
>         if (nanos >= 0) {
>             Thread thread = currentThread();
>             if (thread.isVirtual()) {
>                 if (ThreadSleepEvent.isTurnedOn()) {
>                     ThreadSleepEvent event = new ThreadSleepEvent();
>                     try {
>                         event.time = nanos;
>                         event.begin();
>                         ((VirtualThread) thread).sleepNanos(nanos);
>                     } finally {
>                         event.commit();
>                     }
>                 } else {
>                     ((VirtualThread) thread).sleepNanos(nanos);
>                 }
>             } else {
>                 // convert to milliseconds, ceiling rounding mode
>                 long millis = MILLISECONDS.convert(nanos, NANOSECONDS);
>                 if (nanos > NANOSECONDS.convert(millis, MILLISECONDS)) {
>                     millis += 1L;
>                 }
>                 sleep(millis);
>             }
>         }
>     }
> 
>     /**
380c497,509
<      * Initializes a Thread.
---
>      * Returns the context class loader to inherit from the given parent thread
>      */
>     private static ClassLoader contextClassLoader(Thread parent) {
>         SecurityManager sm = System.getSecurityManager();
>         if (sm == null || isCCLOverridden(parent.getClass())) {
>             return parent.getContextClassLoader();
>         } else {
>             return parent.contextClassLoader;
>         }
>     }
> 
>     /**
>      * Initializes a kernel Thread.
383d511
<      * @param target the object whose run() method gets called
384a513,515
>      * @param characteristics thread characteristics
>      * @param task the object whose run() method gets called
> 
389,390c520
<      * @param inheritThreadLocals if {@code true}, inherit initial values for
<      *            inheritable thread-locals from the constructing thread
---
>      * @throws IllegalArgumentException if invalid characteristics are specified
392,394c522,523
<     private Thread(ThreadGroup g, Runnable target, String name,
<                    long stackSize, AccessControlContext acc,
<                    boolean inheritThreadLocals) {
---
>     private Thread(ThreadGroup g, String name, int characteristics, Runnable task,
>                    long stackSize, AccessControlContext acc) {
398,399c527
< 
<         this.name = name;
---
>         checkCharacteristics(characteristics);
401a530,531
>         boolean primordial = (parent == this);
> 
415c545,546
<                 g = parent.getThreadGroup();
---
>                 // avoid parent.getThreadGroup() during early startup
>                 g = getCurrentThreadGroup();
418a550,554
>         /* can't create a kernel thread in the virtual thread group */
>         if ((VM.initLevel() >= 1) && g == VirtualThreads.THREAD_GROUP) {
>             g = VirtualThreads.THREAD_SUBGROUP;
>         }
> 
433c569,608
<         g.addUnstarted();
---
>         this.name = name;
>         this.tid = primordial ? 1 : ThreadIdentifiers.next();
>         this.contextClassLoader = contextClassLoader(parent);
>         this.inheritedAccessControlContext = (acc != null) ? acc : AccessController.getContext();
> 
>         // thread locals
>         if ((characteristics & NO_THREAD_LOCALS) != 0) {
>             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
>             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
>         } else if ((characteristics & INHERIT_THREAD_LOCALS) != 0) {
>             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
>             if (parentMap != null && parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
>                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
>             }
>         }
> 
>         int priority;
>         boolean daemon;
>         if (primordial) {
>             // primordial or attached thread
>             priority = NORM_PRIORITY;
>             daemon = false;
>         } else {
>             priority = Math.min(parent.getPriority(), g.getMaxPriority());
>             daemon = parent.isDaemon();
>         }
>         this.holder = new FieldHolder(g, task, stackSize, priority, daemon);
>     }
> 
>     /**
>      * Initializes a virtual Thread.
>      *
>      * @param name thread name, can be null
>      * @param characteristics thread characteristics
>      * @throws IllegalArgumentException if invalid characteristics are specified
>      */
>     Thread(String name, int characteristics) {
>         checkCharacteristics(characteristics);
> 
>         Thread parent = currentThread();
435,450c610,624
<         this.group = g;
<         this.daemon = parent.isDaemon();
<         this.priority = parent.getPriority();
<         if (security == null || isCCLOverridden(parent.getClass()))
<             this.contextClassLoader = parent.getContextClassLoader();
<         else
<             this.contextClassLoader = parent.contextClassLoader;
<         this.inheritedAccessControlContext =
<                 acc != null ? acc : AccessController.getContext();
<         this.target = target;
<         setPriority(priority);
<         if (inheritThreadLocals && parent.inheritableThreadLocals != null)
<             this.inheritableThreadLocals =
<                 ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
<         /* Stash the specified stack size in case the VM cares */
<         this.stackSize = stackSize;
---
>         this.name = (name != null) ? name : "<unnamed>";
>         this.tid = ThreadIdentifiers.next();
>         this.contextClassLoader = contextClassLoader(parent);
>         this.inheritedAccessControlContext = VirtualThreads.ACCESS_CONTROL_CONTEXT;
> 
>         // thread locals
>         if ((characteristics & NO_THREAD_LOCALS) != 0) {
>             this.threadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
>             this.inheritableThreadLocals = ThreadLocal.ThreadLocalMap.NOT_SUPPORTED;
>         } else if ((characteristics & INHERIT_THREAD_LOCALS) != 0) {
>             ThreadLocal.ThreadLocalMap parentMap = parent.inheritableThreadLocals;
>             if (parentMap != null && parentMap != ThreadLocal.ThreadLocalMap.NOT_SUPPORTED) {
>                 this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parentMap);
>             }
>         }
452,453c626,1201
<         /* Set thread ID */
<         this.tid = nextThreadID();
---
>         // no additional fields
>         this.holder = null;
>     }
> 
>     /**
>      * The task {@link java.util.concurrent.Executor#execute(Runnable) submitted}
>      * to a custom {@link Thread.Builder#virtual(Executor) scheduler}.
>      *
>      * @apiNote The follow example creates a scheduler that uses a small set of
>      * kernel threads. It prints the name of each virtual thread before executing
>      * its task.
>      * <pre>{@code
>      *     ExecutorService pool = Executors.newFixedThreadPool(4);
>      *     Executor scheduler = (task) -> {
>      *         Thread vthread = ((Thread.VirtualThreadTask) task).thread();
>      *         System.out.println(vthread);
>      *         pool.execute(task);
>      *     };
>      * }</pre>
>      *
>      * @see Thread.Builder#virtual(Executor) 
>      * @since 99
>      */
>     public interface VirtualThreadTask extends Runnable {
>         /**
>          * Return the virtual thread that this task was submitted to run
>          * @return the virtual thread
>          */
>         Thread thread();
> 
>         /**
>          * Attaches the given object to this task.
>          * @param att the object to attach
>          * @return the previously-attached object, if any, otherwise {@code null}
>          */
>         Object attach(Object att);
> 
>         /**
>          * Retrieves the current attachment.
>          * @return the object currently attached to this task or {@code null} if
>          *         there is no attachment
>          */
>         Object attachment();
> 
>         /**
>          * Runs the task on the current thread as the carrier thread.
>          *
>          * <p> Invoking this method with the interrupt status set will first
>          * clear the interrupt status. Interrupting the carrier thread while
>          * running the task leads to unspecified behavior.
>          *
>          * @throws IllegalStateException if the virtual thread is not in a state to
>          *         run on the current thread
>          * @throws IllegalCallerException if the current thread is a virtual thread
>          */
>         @Override
>         void run();
>     }
> 
>     /**
>      * Returns a builder for creating {@code Thread} or {@code ThreadFactory} objects.
>      *
>      * @apiNote The following are examples using the builder:
>      *
>      * <pre>{@code
>      *   // Create a daemon thread that is scheduled by the operating system
>      *   Thread thread = Thread.builder()
>      *                 .name("duke")
>      *                 .daemon(true)
>      *                 .priority(Thread.NORM_PRIORITY)
>      *                 .inheritThreadLocals()
>      *                 .task(...)
>      *                 .build();
>      *
>      *   // A ThreadFactory that creates daemon threads named "worker-0", "worker-1", ...
>      *   ThreadFactory factory = Thread.builder().daemon(true).name("worker-", 0).factory();
>      *
>      *   // Create an unnamed virtual thread
>      *   Thread thread1 = Thread.builder().virtual().task(...).build();
>      *
>      *   // Create a named virtual thread
>      *   Thread thread2 = Thread.builder().virtual().name("duke").task(...).build();
>      *
>      *   // Create and start a virtual thread
>      *   Thread thread = Thread.builder().virtual().task(...).start();
>      *
>      *   // A ThreadFactory that creates virtual threads
>      *   ThreadFactory factory = Thread.builder().virtual().factory();
>      *
>      *   // A ThreadFactory that creates virtual threads and uses a custom scheduler
>      *   Executor scheduler = ...
>      *   ThreadFactory factory = Thread.builder().virtual(scheduler).factory();
>      * }</pre>
>      *
>      * @return A builder for creating {@code Thread} or {@code ThreadFactory} objects.
>      *
>      * @since 99
>      */
>     public static Builder builder() {
>         return new BuilderImpl();
>     }
> 
>     /**
>      * A mutable builder for a {@link Thread} or {@link ThreadFactory}.
>      *
>      * <p> {@code Builder} defines methods to set the {@code Thread} characteristics
>      * and features. Once set, a {@code Thread} or {@code ThreadFactory} can be
>      * created with the following methods:
>      *
>      * <ul>
>      *     <li> The {@linkplain #build() build} method creates an unstarted {@code Thread}.
>      *     <li> The {@linkplain #start() start} method creates and starts a {@code Thread}.
>      *     <li> The {@linkplain #factory() factory} method creates a {@code ThreadFactory}.
>      * </ul>
>      *
>      * <p> A {@code Builder} is not thread safe. The {@code ThreadFactory}
>      * returned by the builder's {@code factory() method} is thread safe.
>      *
>      * <p> Unless otherwise specified, passing a null argument to a method in
>      * this interface causes a {@code NullPointerException} to be thrown.
>      *
>      * @apiNote {@code Builder} checks invariants as components are added to the builder.
>      * The rationale for this is to detect errors as early as possible and not defer
>      * all validation to the {@code build} method.
>      *
>      * @see Thread#builder()
>      * @since 99
>      */
>     public interface Builder {
> 
>         /**
>          * Sets the thread group. The thread group of a virtual thread cannot
>          * be selected at build time. Setting the thread group of a virtual
>          * thread has no effect.
>          * @param group the thread group
>          * @return this builder
>          */
>         Builder group(ThreadGroup group);
> 
>         /**
>          * Sets the thread name.
>          * @param name thread name
>          * @return this builder
>          */
>         Builder name(String name);
> 
>         /**
>          * Sets the thread name to be the concatenation of a string prefix and
>          * a counter value.
>          * @param prefix thread name prefix
>          * @param start counter start
>          * @return this builder
>          * @throws IllegalArgumentException if count is negative
>          */
>         Builder name(String prefix, int start);
> 
>         /**
>          * The thread will be scheduled by the Java virtual machine rather than
>          * the operating system. The scheduler will be selected when the thread
>          * is {@linkplain #build() created} or {@linkplain #start() started}.
>          * @return this builder
>          */
>         Builder virtual();
> 
>         /**
>          * The thread will be scheduled by the Java virtual machine rather than
>          * the operating system with the given scheduler. The scheduler's {@link
>          * Executor#execute(Runnable) execute} method is invoked with tasks of
>          * type {@link VirtualThreadTask}. It may be invoked in the context of
>          * a virtual thread. The scheduler should arrange to execute these tasks
>          * on a kernel thread. Attempting to execute the task on a virtual thread
>          * causes an exception to be thrown (see {@link VirtualThreadTask#run()}).
>          * The {@code execute} method may be invoked at sensitive times (e.g. when
>          * unparking a thread) so care should be taken to not directly execute the
>          * task on the <em>current thread</em>.
>          * @param scheduler the scheduler or {@code null} for the default scheduler
>          * @return this builder
>          */
>         Builder virtual(Executor scheduler);
> 
>         /**
>          * Disallow threads locals. If the thread attempts to set a value for
>          * a thread-local with the {@link ThreadLocal#set(Object)} method then
>          * {@code UnsupportedOperationException} is thrown.
>          * @return this builder
>          * @see ThreadLocal#set(Object)
>          */
>         Builder disallowThreadLocals();
> 
>         /**
>          * Inherit threads-locals. Thread locals are inherited when the {@code Thread}
>          * is created with the {@link #build() build} method or when the thread
>          * factory {@link ThreadFactory#newThread(Runnable) newThread} method
>          * is invoked. This method has no effect when thread locals are {@linkplain
>          * #disallowThreadLocals() disallowed}.
>          * @return this builder
>          */
>         Builder inheritThreadLocals();
> 
>         /**
>          * Sets the daemon status.
>          * The {@link #isDaemon() daemon status} of virtual threads is always {@code true}.
>          * Setting the daemon status of a virtual thread has no effect.
>          * @param on {@code true} to create daemon threads
>          * @return this builder
>          */
>         Builder daemon(boolean on);
> 
>         /**
>          * Sets the thread priority.
>          * The priority of virtual threads is always {@linkplain Thread#NORM_PRIORITY}.
>          * Setting the priority of a virtual thread has no effect.
>          * @param priority priority
>          * @return this builder
>          * @throws IllegalArgumentException if the priority is less than
>          *        {@link Thread#MIN_PRIORITY} or greater than {@link Thread#MAX_PRIORITY}
>          */
>         Builder priority(int priority);
> 
>         /**
>          * Sets the uncaught exception handler.
>          * @param ueh uncaught exception handler
>          * @return this builder
>          */
>         Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh);
> 
>         /**
>          * Sets the task for the thread to run.
>          * @param task the task to run
>          * @return this builder
>          */
>         Builder task(Runnable task);
> 
>         /**
>          * Creates a new unstarted {@code Thread} from the current state of the
>          * builder.
>          *
>          * <p> When this method creates a kernel thread then it will inherit the
>          * {@linkplain ThreadGroup thread-group}, {@linkplain #getPriority() priority},
>          * and {@linkplain #isDaemon() daemon status} of the current thread if these
>          * characteristics have not been set. The {@linkplain #getContextClassLoader()
>          * context-class-loader} is inherited from the current thread.
>          *
>          * <p> When this method creates a virtual thread and a scheduler has not
>          * been set then the thread will be scheduled using the default scheduler if
>          * the current thread is a kernel thread, or the scheduler for the current
>          * thread if it is a virtual thread. The {@link #getContextClassLoader()
>          * context-class-loader} is inherited from the current thread. The thread
>          * will have no {@link java.security.Permission permissions}.
>          *
>          * @return a new unstarted Thread
>          * @throws IllegalStateException if the task object to run object has not been set
>          * @throws SecurityException if a thread group has been set and the current thread
>          *         cannot create a thread in that thread group
>          */
>         Thread build();
> 
>         /**
>          * Returns a {@code ThreadFactory} to create threads from the current
>          * state of the builder. The returned thread factory is safe for use by
>          * multiple concurrent threads.
>          *
>          * <p> A {@code ThreadFactory} that creates kernel threads will inherit the
>          * {@linkplain ThreadGroup thread-group}, {@linkplain #getPriority()
>          * priority}, and {@linkplain #isDaemon() daemon status} of the current
>          * thread when creating a {@code Thread} if these characteristics have not
>          * been set. The {@linkplain #getContextClassLoader() context-class-loader}
>          * is inherited from the current thread when creating a {@code Thread}.
>          *
>          * <p> A {@code ThreadFactory} that creates virtual threads will use the
>          * selected scheduler. If a scheduler has not been set then the {@code
>          * ThreadFactory} will select the scheduler when creating a {@code Thread}.
>          * The default scheduler will be selected if the current thread is a
>          * kernel thread. It will use the scheduler for the current thread if it
>          * is a virtual thread. The {@link #getContextClassLoader() context-class-loader}
>          * is inherited from the current thread. The thread will have no
>          * {@link java.security.Permission permissions}.
>          *
>          * @return a thread factory to create threads
>          */
>         ThreadFactory factory();
> 
>         /**
>          * Creates a new {@code Thread} from the current state of the builder
>          * and starts it as if by invoking the {@linkplain Thread#start() start}
>          * method.
>          *
>          * <p> When this method starts a kernel thread then it will inherit the
>          * {@linkplain ThreadGroup thread-group}, {@linkplain #getPriority() priority},
>          * and {@linkplain #isDaemon() daemon status} of the current thread if these
>          * characteristics have not been set. The {@linkplain #getContextClassLoader()
>          * context-class-loader} is inherited from the current thread.
>          *
>          * <p> When this method starts a virtual thread and a scheduler has not
>          * been set then the thread will be scheduled using the default scheduler if
>          * the current thread is a kernel thread, or the scheduler for the current
>          * thread if it is a virtual thread. The {@link #getContextClassLoader()
>          * context-class-loader} is inherited from the current thread. The thread
>          * will have no {@link java.security.Permission permissions}.
>          *
>          * @implSpec The default implementation invokes {@linkplain #build() build}
>          * to create a {@code Thread} and then invokes its {@linkplain Thread#start()
>          * start} method to start it.
>          *
>          * @return The started thread
>          * @throws IllegalStateException if the task object to run object has not been set
>          * @throws SecurityException if a thread group has been set and the current thread
>          *         cannot create a thread in that thread group
>          */
>         default Thread start() {
>             Thread thread = build();
>             thread.start();
>             return thread;
>         }
>     }
> 
>     private static class BuilderImpl implements Builder {
>         private ThreadGroup group;
>         private Executor scheduler;
>         private String name;
>         private int counter;
>         private boolean virtual;
>         private boolean disallowThreadLocals;
>         private boolean inheritThreadLocals;
>         private boolean daemon;
>         private boolean daemonChanged;
>         private int priority;
>         private UncaughtExceptionHandler uhe;
>         private Runnable task;
> 
>         BuilderImpl() { }
> 
>         private int characteristics() {
>             int characteristics = 0;
>             if (virtual)
>                 characteristics |= Thread.VIRTUAL;
>             if (disallowThreadLocals)
>                 characteristics |= Thread.NO_THREAD_LOCALS;
>             if (inheritThreadLocals)
>                 characteristics |= Thread.INHERIT_THREAD_LOCALS;
>             return characteristics;
>         }
> 
>         @Override
>         public Builder group(ThreadGroup group) {
>             Objects.requireNonNull(group);
>             if (!virtual)
>                 this.group = group;
>             return this;
>         }
> 
>         @Override
>         public Builder name(String name) {
>             this.name = Objects.requireNonNull(name);
>             this.counter = -1;
>             return this;
>         }
> 
>         @Override
>         public Builder name(String prefix, int start) {
>             Objects.requireNonNull(prefix);
>             if (start < 0)
>                 throw new IllegalArgumentException("'start' is negative");
>             this.name = prefix;
>             this.counter = start;
>             return this;
>         }
> 
>         @Override
>         public Builder virtual() {
>             this.group = null;
>             this.scheduler = null;
>             this.virtual = true;
>             return this;
>         }
> 
>         @Override
>         public Builder virtual(Executor scheduler) {
>             if (scheduler == null)
>                 scheduler = VirtualThread.defaultScheduler();
>             this.group = null;
>             this.scheduler = scheduler;
>             this.virtual = true;
>             return this;
>         }
> 
>         @Override
>         public Builder disallowThreadLocals() {
>             this.disallowThreadLocals = true;
>             this.inheritThreadLocals = false;
>             return this;
>         }
> 
>         @Override
>         public Builder inheritThreadLocals() {
>             if (!disallowThreadLocals)
>                 this.inheritThreadLocals = true;
>             return this;
>         }
> 
>         @Override
>         public Builder daemon(boolean on) {
>             daemon = on;
>             daemonChanged = true;
>             return this;
>         }
> 
>         @Override
>         public Builder priority(int priority) {
>             if (priority < Thread.MIN_PRIORITY || priority > Thread.MAX_PRIORITY)
>                 throw new IllegalArgumentException();
>             this.priority = priority;
>             return this;
>         }
> 
>         @Override
>         public Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh) {
>             this.uhe = Objects.requireNonNull(ueh);
>             return this;
>         }
> 
>         @Override
>         public Thread build() {
>             Runnable task = this.task;
>             if (task == null)
>                 throw new IllegalStateException("No task specified");
> 
>             int characteristics = characteristics();
>             Thread thread;
>             if ((characteristics & Thread.VIRTUAL) != 0) {
>                 String name = this.name;
>                 if (name != null && counter >= 0) {
>                     name = name + (counter++);
>                 }
>                 thread = new VirtualThread(scheduler, name, characteristics, task);
>             } else {
>                 String name = this.name;
>                 if (name == null) {
>                     name = "Thread-" + nextThreadNum();
>                 } else if (counter >= 0) {
>                     name = name + (counter++);
>                 }
>                 thread = new Thread(group, name, characteristics, task, 0, null);
>                 if (daemonChanged)
>                     thread.daemon(daemon);
>                 if (priority != 0)
>                     thread.priority(priority);
>             }
>             if (uhe != null)
>                 thread.uncaughtExceptionHandler(uhe);
>             return thread;
>         }
> 
>         @Override
>         public Builder task(Runnable task) {
>             this.task = Objects.requireNonNull(task);
>             return this;
>         }
> 
>         @Override
>         public ThreadFactory factory() {
>             int characteristics = characteristics();
>             if ((characteristics & Thread.VIRTUAL) != 0) {
>                 return new VirtualThreadFactory(scheduler, name, counter, characteristics, uhe);
>             } else {
>                 return new KernelThreadFactory(group, name, counter, characteristics,
>                                                daemon, priority, uhe);
>             }
>         }
>     }
> 
>     private static abstract class CountingThreadFactory implements ThreadFactory {
>         private static final VarHandle COUNT;
>         static {
>             try {
>                 MethodHandles.Lookup l = MethodHandles.lookup();
>                 COUNT = l.findVarHandle(CountingThreadFactory.class, "count", int.class);
>             } catch (Exception e) {
>                 throw new InternalError(e);
>             }
>         }
>         private volatile int count;
>         private final boolean hasCounter;
> 
>         CountingThreadFactory(int start) {
>             if (start >= 0) {
>                 count = start;
>                 hasCounter = true;
>             } else {
>                 hasCounter = false;
>             }
>         }
> 
>         boolean hasCounter() {
>             return hasCounter;
>         }
> 
>         int next() {
>             return (int) COUNT.getAndAdd(this, 1);
>         }
>     }
> 
>     private static class VirtualThreadFactory extends CountingThreadFactory {
>         private final Executor scheduler;
>         private final String name;
>         private final int characteristics;
>         private final UncaughtExceptionHandler uhe;
> 
>         VirtualThreadFactory(Executor scheduler,
>                              String name,
>                              int start,
>                              int characteristics,
>                              UncaughtExceptionHandler uhe) {
>             super(start);
>             this.scheduler = scheduler;
>             this.name = name;
>             this.characteristics = characteristics;
>             this.uhe = uhe;
>         }
> 
>         @Override
>         public Thread newThread(Runnable task) {
>             Objects.requireNonNull(task);
>             String name = this.name;
>             if (name != null && hasCounter()) {
>                 name += next();
>             }
>             Thread thread = new VirtualThread(scheduler, name, characteristics, task);
>             if (uhe != null)
>                 thread.uncaughtExceptionHandler(uhe);
>             return thread;
>         }
>     }
> 
>     private static class KernelThreadFactory extends CountingThreadFactory {
>         private final ThreadGroup group;
>         private final String name;
>         private final int characteristics;
>         private final boolean daemon;
>         private final int priority;
>         private final UncaughtExceptionHandler uhe;
> 
>         KernelThreadFactory(ThreadGroup group,
>                             String name,
>                             int start,
>                             int characteristics,
>                             boolean daemon,
>                             int priority,
>                             UncaughtExceptionHandler uhe) {
>             super(start);
>             this.group = group;
>             this.name = name;
>             this.characteristics = characteristics;
>             this.daemon = daemon;
>             this.priority = priority;
>             this.uhe = uhe;
>         }
> 
>         @Override
>         public Thread newThread(Runnable task) {
>             Objects.requireNonNull(task);
>             String name = this.name;
>             if (name == null) {
>                 name = "Thread-" + nextThreadNum();
>             } else if (hasCounter()) {
>                 name += next();
>             }
>             Thread thread = new Thread(group, name, characteristics, task, 0, null);
>             if (daemon)
>                 thread.daemon(true);
>             if (priority != 0)
>                 thread.priority(priority);
>             if (uhe != null)
>                 thread.uncaughtExceptionHandler(uhe);
>             return thread;
>         }
482c1230
<      * {@code (null, target, gname)}, where {@code gname} is a newly generated
---
>      * {@code (null, task, gname)}, where {@code gname} is a newly generated
486c1234
<      * @param  target
---
>      * @param  task
491,492c1239,1240
<     public Thread(Runnable target) {
<         this(null, target, "Thread-" + nextThreadNum(), 0);
---
>     public Thread(Runnable task) {
>         this(null, task, "Thread-" + nextThreadNum(), 0);
500,501c1248,1249
<     Thread(Runnable target, AccessControlContext acc) {
<         this(null, target, "Thread-" + nextThreadNum(), 0, acc, false);
---
>     Thread(Runnable task, AccessControlContext acc) {
>         this(null, "Thread-" + nextThreadNum(), 0, task, 0, acc);
507c1255
<      * {@code (group, target, gname)} ,where {@code gname} is a newly generated
---
>      * {@code (group, task, gname)} ,where {@code gname} is a newly generated
519c1267
<      * @param  target
---
>      * @param  task
527,528c1275,1276
<     public Thread(ThreadGroup group, Runnable target) {
<         this(group, target, "Thread-" + nextThreadNum(), 0);
---
>     public Thread(ThreadGroup group, Runnable task) {
>         this(group, task, "Thread-" + nextThreadNum(), 0);
570c1318
<      * {@code (null, target, name)}.
---
>      * {@code (null, task, name)}.
572c1320
<      * @param  target
---
>      * @param  task
579,580c1327,1328
<     public Thread(Runnable target, String name) {
<         this(null, target, name, 0);
---
>     public Thread(Runnable task, String name) {
>         this(null, task, name, 0);
584c1332
<      * Allocates a new {@code Thread} object so that it has {@code target}
---
>      * Allocates a new {@code Thread} object so that it has {@code task}
598,601c1346,1349
<      * <p>The priority of the newly created thread is set equal to the
<      * priority of the thread creating it, that is, the currently running
<      * thread. The method {@linkplain #setPriority setPriority} may be
<      * used to change the priority to a new value.
---
>      * <p>The priority of the newly created thread is the smaller of
>      * priority of the thread creating it and the maximum permitted
>      * priority of the thread group. The method {@linkplain #setPriority
>      * setPriority} may be used to change the priority to a new value.
616c1364
<      * @param  target
---
>      * @param  task
627,628c1375,1376
<     public Thread(ThreadGroup group, Runnable target, String name) {
<         this(group, target, name, 0);
---
>     public Thread(ThreadGroup group, Runnable task, String name) {
>         this(group, task, name, 0);
632c1380
<      * Allocates a new {@code Thread} object so that it has {@code target}
---
>      * Allocates a new {@code Thread} object so that it has {@code task}
688c1436
<      * @param  target
---
>      * @param  task
705,707c1453,1454
<     public Thread(ThreadGroup group, Runnable target, String name,
<                   long stackSize) {
<         this(group, target, name, stackSize, null, true);
---
>     public Thread(ThreadGroup group, Runnable task, String name, long stackSize) {
>         this(group, name, Thread.INHERIT_THREAD_LOCALS, task, stackSize, null);
711c1458
<      * Allocates a new {@code Thread} object so that it has {@code target}
---
>      * Allocates a new {@code Thread} object so that it has {@code task}
739c1486
<      * @param  target
---
>      * @param  task
761c1508
<     public Thread(ThreadGroup group, Runnable target, String name,
---
>     public Thread(ThreadGroup group, Runnable task, String name,
763c1510,1511
<         this(group, target, name, stackSize, null, inheritThreadLocals);
---
>         this(group, name, (inheritThreadLocals ? Thread.INHERIT_THREAD_LOCALS : 0),
>                 task, stackSize, null);
767,773c1515,1669
<      * Causes this thread to begin execution; the Java Virtual Machine
<      * calls the {@code run} method of this thread.
<      * <p>
<      * The result is that two threads are running concurrently: the
<      * current thread (which returns from the call to the
<      * {@code start} method) and the other thread (which executes its
<      * {@code run} method).
---
>      * Characteristic value signifying that the thread should be scheduled by
>      * the Java virtual machine rather than the operating system.
>      *
>      * @since 99
>      */
>     public static final int VIRTUAL = 1 << 0;
> 
>     /**
>      * Characteristic value signifying that {@link ThreadLocal thread-locals}
>      * are not supported by the thread.
>      *
>      * @apiNote This is for experimental purposes, a lot of existing code will
>      * not run if thread locals are not supported.
>      *
>      * @since 99
>      */
>     public static final int NO_THREAD_LOCALS = 1 << 1;
> 
>     /**
>      * Characteristic value signifying that {@link InheritableThreadLocal
>      * inheritable-thread-locals} are inherihted from the constructing thread.
>      * This characteristic is incompatible with {@linkplain #NO_THREAD_LOCALS},
>      * they may not be used together.
>      *
>      * @since 99
>      */
>     public static final int INHERIT_THREAD_LOCALS = 1 << 2;
> 
>     private static int validCharacteristics() {
>         return (VIRTUAL | NO_THREAD_LOCALS | INHERIT_THREAD_LOCALS);
>     }
> 
>     private static void checkCharacteristics(int characteristics) {
>         if (characteristics != 0) {
>             if ((characteristics & ~validCharacteristics()) != 0)
>                 throw new IllegalArgumentException();
>             if ((characteristics & NO_THREAD_LOCALS) != 0
>                     && (characteristics & INHERIT_THREAD_LOCALS) != 0)
>                 throw new IllegalArgumentException();
>         }
>     }
> 
>     /**
>      * Creates an unnamed thread.
>      *
>      * By default, the thread is scheduled by the operating system, supports
>      * {@linkplain ThreadLocal thread-locals}, and does not inherit any initial
>      * values for {@linkplain InheritableThreadLocal inheritable-thread-locals}.
>      * The {@linkplain ThreadGroup thread-group}, {@link #isDaemon() daemon status},
>      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
>      * context-class-loader} are inherited from the current thread.
>      *
>      * <p> The characteristic {@link Thread#VIRTUAL VIRTUAL} is used to create
>      * a thread that is scheduled by the Java virtual machine. The thread will
>      * be scheduled using the default scheduler if the current thread is a kernel
>      * thread, or the scheduler for the current thread if it is a virtual thread.
>      * The {@linkplain #getContextClassLoader() context-class-loader} is inherited
>      * from the current thread. The thread will will have no {@link
>      * java.security.Permission permissions}.
>      *
>      * @apiNote The characteristics will probably be replaced by an enum
>      *
>      * @param characteristics characteristics of the thread
>      * @param task the object to run when the thread executes
>      * @throws IllegalArgumentException if an unknown characteristic or an invalid
>      *         combination of characteristic is specified
>      * @throws NullPointerException if task is null
>      * @return an un-started virtual thread
>      *
>      * @since 99
>      */
>     public static Thread newThread(int characteristics, Runnable task) {
>         if ((characteristics & VIRTUAL) != 0) {
>             return new VirtualThread(null, null, characteristics, task);
>         } else {
>             return new Thread(null, "Thread-" + nextThreadNum(), characteristics, task, 0, null);
>         }
>     }
> 
>     /**
>      * Creates a named thread.
>      *
>      * By default, the thread is scheduled by the operating system, supports
>      * {@linkplain ThreadLocal thread-locals}, and does not inherit any initial
>      * values for {@linkplain InheritableThreadLocal inheritable-thread-locals}.
>      * The {@linkplain ThreadGroup thread-group}, {@link #isDaemon() daemon status},
>      * {@link #getPriority() priority}, and the {@link #getContextClassLoader()
>      * context-class-loader} are inherited from the current thread.
>      *
>      * <p> The characteristic {@link Thread#VIRTUAL VIRTUAL} is used to create
>      * a thread that is scheduled by the Java virtual machine. The thread will
>      * be scheduled using the default scheduler if the current thread is a kernel
>      * thread, or the scheduler for the current thread if it is a virtual thread.
>      * The {@linkplain #getContextClassLoader() context-class-loader} is inherited
>      * from the current thread. The thread will will have no {@link
>      * java.security.Permission permissions}.
>      *
>      * @apiNote The characteristics will probably be replaced by an enum
>      *
>      * @param name the thread name
>      * @param characteristics characteristics of the thread
>      * @param task the object to run when the thread executes
>      * @throws IllegalArgumentException if an unknown characteristic or an invalid
>      *         combination of characteristic is specified
>      * @throws NullPointerException if name or task is null
>      * @return an un-started virtual thread
>      *
>      * @since 99
>      */
>     public static Thread newThread(String name, int characteristics, Runnable task) {
>         Objects.requireNonNull(name);
>         Objects.requireNonNull(task);
>         if ((characteristics & VIRTUAL) != 0) {
>             return new VirtualThread(null, name, characteristics, task);
>         } else {
>             return new Thread(null, name, characteristics, task, 0, null);
>         }
>     }
> 
>     /**
>      * Starts a new virtual thread to execute a task. The thread is scheduled
>      * by the Java virtual machine using the default scheduler if the current
>      * thread is a kernel thread, or the scheduler for the current thread if
>      * it is a virtual thread. The resulting thread supports {@linkplain
>      * ThreadLocal thread-locals} but does not inherit any initial values for
>      * {@linkplain InheritableThreadLocal inheritable-thread-locals}. It inherits
>      * the {@linkplain #getContextClassLoader() context-class-loader} from the
>      * current thread. It has no {@link java.security.Permission permissions}.
>      * @param task the object to run when the thread executes
>      * @throws NullPointerException if task is null
>      * @return a new, and started, virtual thread
>      * @since 99
>      */
>     public static Thread startVirtualThread(Runnable task) {
>         Objects.requireNonNull(task);
>         var thread = new VirtualThread(null, null, VIRTUAL, task);
>         thread.start();
>         return thread;
>     }
> 
>     /**
>      * Returns {@code true} if this thread is a virtual thread. A virtual thread
>      * is scheduled by the Java virtual machine rather than the operating system.
>      *
>      * @return {@code true} if this thread is a virtual thread
>      *
>      * @since 99
>      */
>     public final boolean isVirtual() {
>         return (this instanceof VirtualThread);
>     }
> 
>     /**
>      * Schedules this thread to begin execution. The thread will execute
>      * independently of the current thread.
779a1676,1677
>      * @throws     java.util.concurrent.RejectedExecutionException if the thread
>      *             is virtual and the scheduler cannot accept a task
781c1679
<      * @see        #stop()
---
>      * @see        Builder#start()
791c1689
<         if (threadStatus != 0)
---
>         if (holder.threadStatus != 0)
794,812c1692
<         /* Notify the group that this thread is about to be started
<          * so that it can be added to the group's list of threads
<          * and the group's unstarted count can be decremented. */
<         group.add(this);
< 
<         boolean started = false;
<         try {
<             start0();
<             started = true;
<         } finally {
<             try {
<                 if (!started) {
<                     group.threadStartFailed(this);
<                 }
<             } catch (Throwable ignore) {
<                 /* do nothing. If start0 threw a Throwable then
<                   it will be passed up the call stack */
<             }
<         }
---
>         start0();
821a1702,1703
>      * This method does nothing when invoked on a {@linkplain #isVirtual()
>      * virtual} thread.
826d1707
<      * @see     #stop()
831,832c1712,1716
<         if (target != null) {
<             target.run();
---
>         if (!isVirtual()) {
>             Runnable task = holder.task;
>             if (task != null) {
>                 task.run();
>             }
841,846c1725,1737
<         if (threadLocals != null && TerminatingThreadLocal.REGISTRY.isPresent()) {
<             TerminatingThreadLocal.threadTerminated();
<         }
<         if (group != null) {
<             group.threadTerminated(this);
<             group = null;
---
>         // assert !isVirtual();
>         try {
>             if (threadLocals != null && TerminatingThreadLocal.REGISTRY.isPresent()) {
>                 TerminatingThreadLocal.threadTerminated();
>             }
>         } finally {
>             /* Aggressively null out all reference fields: see bug 4006245 */
>             /* Speed the release of some of these resources */
>             threadLocals = null;
>             inheritableThreadLocals = null;
>             inheritedAccessControlContext = null;
>             nioBlocker = null;
>             uncaughtExceptionHandler = null;
848,855d1738
<         /* Aggressively null out all reference fields: see bug 4006245 */
<         target = null;
<         /* Speed the release of some of these resources */
<         threadLocals = null;
<         inheritableThreadLocals = null;
<         inheritedAccessControlContext = null;
<         blocker = null;
<         uncaughtExceptionHandler = null;
886c1769
<      * officially dies).  If a {@code catch} clause catches a
---
>      * officially terminates).  If a {@code catch} clause catches a
888c1771
<      * object so that the thread actually dies.
---
>      * object so that the thread actually terminates.
896a1780
>      * @throws     UnsupportedOperationException if invoked on a virtual thread
913,914c1797,1798
<      *       modifies some variable to indicate that the target thread should
<      *       stop running.  The target thread should check this variable
---
>      *       modifies some variable to indicate that the task thread should
>      *       stop running.  The task thread should check this variable
917c1801
<      *       target thread waits for long periods (on a condition variable,
---
>      *       task thread waits for long periods (on a condition variable,
932a1817,1820
> 
>         if (isVirtual())
>             throw new UnsupportedOperationException();
> 
935c1823
<         if (threadStatus != 0) {
---
>         if (holder.threadStatus != 0) {
991,992c1879,1880
<             synchronized (blockerLock) {
<                 Interruptible b = blocker;
---
>             synchronized (interruptLock) {
>                 Interruptible b = nioBlocker;
1002,1003c1890
<         // inform VM of interrupt
<         interrupt0();
---
>         interrupt0();  // inform VM of interrupt
1020,1029c1907
<         Thread t = currentThread();
<         boolean interrupted = t.interrupted;
<         // We may have been interrupted the moment after we read the field,
<         // so only clear the field if we saw that it was set and will return
<         // true; otherwise we could lose an interrupt.
<         if (interrupted) {
<             t.interrupted = false;
<             clearInterruptEvent();
<         }
<         return interrupted;
---
>         return currentThread().getAndClearInterrupt();
1044a1923,1950
>     final void setInterrupt() {
>         // assert Thread.currentCarrierThread() == this;
>         if (!interrupted) {
>             interrupted = true;
>             interrupt0();  // inform VM of interrupt
>         }
>     }
> 
>     final void clearInterrupt() {
>         // assert Thread.currentCarrierThread() == this;
>         if (interrupted) {
>             interrupted = false;
>             clearInterruptEvent();
>         }
>     }
> 
>     boolean getAndClearInterrupt() {
>         boolean oldValue = interrupted;
>         // We may have been interrupted the moment after we read the field,
>         // so only clear the field if we saw that it was set and will return
>         // true; otherwise we could lose an interrupt.
>         if (oldValue) {
>             interrupted = false;
>             clearInterruptEvent();
>         }
>         return oldValue;
>     }
> 
1047c1953
<      * been started and has not yet died.
---
>      * been started and has not yet terminated.
1052c1958,1966
<     public final native boolean isAlive();
---
>     public final boolean isAlive() {
>         if (isVirtual()) {
>             State state = getState();
>             return (state != State.NEW && state != State.TERMINATED);
>         } else {
>             return isAlive0();
>         }
>     }
>     private native boolean isAlive0();
1065a1980
>      * @throws     UnsupportedOperationException if invoked on a virtual thread
1068c1983
<      *   inherently deadlock-prone.  If the target thread holds a lock on the
---
>      *   inherently deadlock-prone.  If the task thread holds a lock on the
1070,1071c1985,1986
<      *   thread can access this resource until the target thread is resumed. If
<      *   the thread that would resume the target thread attempts to lock this
---
>      *   thread can access this resource until the task thread is resumed. If
>      *   the thread that would resume the task thread attempts to lock this
1080a1996,1997
>         if (isVirtual())
>             throw new UnsupportedOperationException();
1095a2013
>      * @throws     UnsupportedOperationException if invoked on a virtual thread
1106a2025,2026
>         if (isVirtual())
>             throw new UnsupportedOperationException();
1115a2036,2037
>      * The priority of virtual-threads is always {@linkplain Thread#NORM_PRIORITY}
>      * and is not changed by this method.
1134d2055
<         ThreadGroup g;
1139,1141c2060,2068
<         if((g = getThreadGroup()) != null) {
<             if (newPriority > g.getMaxPriority()) {
<                 newPriority = g.getMaxPriority();
---
>         priority(newPriority);
>     }
> 
>     void priority(int newPriority) {
>         ThreadGroup g;
>         if (!isVirtual() && (g = getThreadGroup()) != null) {
>             int maxPriority = g.getMaxPriority();
>             if (newPriority > maxPriority) {
>                 newPriority = maxPriority;
1143c2070
<             setPriority0(priority = newPriority);
---
>             setPriority0(holder.priority = newPriority);
1148a2076
>      * The priority of a virtual thread is always {@linkplain Thread#NORM_PRIORITY}.
1154c2082,2086
<         return priority;
---
>         if (isVirtual()) {
>             return Thread.NORM_PRIORITY;
>         } else {
>             return holder.priority;
>         }
1177c2109
<         if (threadStatus != 0) {
---
>         if (!isVirtual() && holder.threadStatus != 0) {
1194,1195c2126,2131
<      * This method returns null if this thread has died
<      * (been stopped).
---
>      * This method returns null if the thread has terminated.
>      *
>      * <p> The thread group for virtual threads does not support all features
>      * of regular thread groups. Virtual threads are not considered <i>active
>      * threads</i> in the thread group and so are not enumerated or acted on by
>      * thread group operations.
1200c2136,2152
<         return group;
---
>         if (getState() == State.TERMINATED) {
>             return null;
>         } else {
>             return isVirtual() ? VirtualThreads.THREAD_GROUP : holder.group;
>         }
>     }
> 
>     /**
>      * Returns the thread group for the current thread.
>      */
>     static ThreadGroup getCurrentThreadGroup() {
>         Thread thread = Thread.currentThread();
>         if (thread.isVirtual()) {
>             return VirtualThreads.THREAD_GROUP;
>         } else {
>             return thread.holder.group;
>         }
1206,1207c2158
<      * subgroups. Recursively iterates over all subgroups in the current
<      * thread's thread group.
---
>      * subgroups.
1217a2169,2170
>      *
>      * @since 1.0
1247a2201,2202
>      *
>      * @since 1.0
1270,1271c2225,2228
<      * Waits at most {@code millis} milliseconds for this thread to
<      * die. A timeout of {@code 0} means to wait forever.
---
>      * Waits at most {@code millis} milliseconds for this thread to terminate.
>      * A timeout of {@code 0} means to wait forever.
>      * This method returns immediately, without waiting, if the thread has not
>      * been {@link #start() started}.
1273c2230,2231
<      * <p> This implementation uses a loop of {@code this.wait} calls
---
>      * <p> For non-{@linkplain #isVirtual() virtual}, this
>      * implementation uses a loop of {@code this.wait} calls
1290,1292c2248,2252
<     public final synchronized void join(final long millis)
<     throws InterruptedException {
<         if (millis > 0) {
---
>     public final void join(long millis) throws InterruptedException {
>         if (millis < 0)
>             throw new IllegalArgumentException("timeout value is negative");
> 
>         if (isVirtual()) {
1294,1303c2254,2273
<                 final long startTime = System.nanoTime();
<                 long delay = millis;
<                 do {
<                     wait(delay);
<                 } while (isAlive() && (delay = millis -
<                         TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) > 0);
<             }
<         } else if (millis == 0) {
<             while (isAlive()) {
<                 wait(0);
---
>                 long nanos = TimeUnit.MILLISECONDS.toNanos(millis);
>                 ((VirtualThread) this).joinNanos(nanos);
>             }
>             return;
>         }
> 
>         synchronized (this) {
>             if (millis > 0) {
>                 if (isAlive()) {
>                     final long startTime = System.nanoTime();
>                     long delay = millis;
>                     do {
>                         wait(delay);
>                     } while (isAlive() && (delay = millis -
>                             TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) > 0);
>                 }
>             } else if (millis == 0) {
>                 while (isAlive()) {
>                     wait(0);
>                 }
1305,1306d2274
<         } else {
<             throw new IllegalArgumentException("timeout value is negative");
1312c2280
<      * {@code nanos} nanoseconds for this thread to die.
---
>      * {@code nanos} nanoseconds for this thread to terminate.
1313a2282,2283
>      * This method returns immediately, without waiting, if the thread has not
>      * been {@link #start() started}.
1314a2285,2286
>      * <p> For non-{@link #isVirtual() virtual}, this
>      * implementation uses a loop of {@code this.wait} calls
1336,1338c2308
<     public final synchronized void join(long millis, int nanos)
<     throws InterruptedException {
< 
---
>     public final void join(long millis, int nanos) throws InterruptedException {
1344,1345c2314
<             throw new IllegalArgumentException(
<                                 "nanosecond timeout value out of range");
---
>             throw new IllegalArgumentException("nanosecond timeout value out of range");
1356c2325
<      * Waits for this thread to die.
---
>      * Waits for this thread to terminate.
1374a2344,2385
>      * Waits for this thread to terminate for up to the given waiting duration.
>      * This method does not wait if the duration to wait is less than or equal
>      * to zero.
>      *
>      * @param   duration
>      *          the maximum duration to wait
>      *
>      * @return  {@code true} if the thread has terminated
>      *
>      * @throws  InterruptedException
>      *          if the current thread is interrupted while waiting.
>      *          The <i>interrupted status</i> of the current thread is cleared
>      *          when this exception is thrown.
>      *
>      * @throws  IllegalThreadStateException
>      *          if this thread has not been started.
>      *
>      * @since 99
>      */
>     public final boolean join(Duration duration) throws InterruptedException {
>         Objects.requireNonNull(duration);
> 
>         Thread.State state = getState();
>         if (state == State.TERMINATED)
>             return true;
>         if (state == State.NEW)
>             throw new IllegalThreadStateException("Thread not started");
>         if (duration.isZero() || duration.isNegative())
>             return false;
> 
>         if (isVirtual()) {
>             long nanos = TimeUnit.NANOSECONDS.convert(duration);
>             return ((VirtualThread) this).joinNanos(nanos);
>         } else {
>             // ignore nano precision for now
>             long millis = Long.max(TimeUnit.MILLISECONDS.convert(duration), 1);
>             join(millis);
>             return getState() == State.TERMINATED;
>         }
>     }
> 
>     /**
1376c2387
<      * This method is used only for debugging.
---
>      * This method is useful for debugging.
1384,1385c2395,2400
<      * or a user thread. The Java Virtual Machine exits when the only
<      * threads running are all daemon threads.
---
>      * or a user thread.
>      * The daemon status of a virtual thread is meaningless and is not
>      * changed by this method (the {@linkplain #isDaemon() isDaemon} method
>      * always returns {@code true}).
>      * The Java Virtual Machine exits when the only threads running are all
>      * daemon threads.
1401c2416
<         if (isAlive()) {
---
>         if (isAlive())
1403,1404c2418,2423
<         }
<         daemon = on;
---
>         daemon(on);
>     }
> 
>     void daemon(boolean on) {
>         if (!isVirtual())
>             holder.daemon = on;
1408a2428,2429
>      * The daemon status of a virtual thread is meaningless, this method
>      * returns {@code true} if this is a virtual thread.
1415c2436,2440
<         return daemon;
---
>         if (isVirtual()) {
>             return true;
>         } else {
>             return holder.daemon;
>         }
1438,1439c2463,2465
<      * Returns a string representation of this thread, including the
<      * thread's name, priority, and thread group.
---
>      * Returns a string representation of this thread. The string representation
>      * will usually include the thread's name. The default implementation
>      * includes the thread's name, priority, and the name of the thread group.
1489a2516,2529
>      * TBD
>      */
>     Continuation getContinuation() {
>         return cont;
>     }
> 
>     /**
>      * TBD
>      */
>     void setContinuation(Continuation cont) {
>         this.cont = cont;
>     }
> 
>     /**
1581,1582c2621
<                 security.checkPermission(
<                     SecurityConstants.GET_STACK_TRACE_PERMISSION);
---
>                 security.checkPermission(SecurityConstants.GET_STACK_TRACE_PERMISSION);
1589,1596c2628
<             StackTraceElement[][] stackTraceArray = dumpThreads(new Thread[] {this});
<             StackTraceElement[] stackTrace = stackTraceArray[0];
<             // a thread that was alive during the previous isAlive call may have
<             // since terminated, therefore not having a stacktrace.
<             if (stackTrace == null) {
<                 stackTrace = EMPTY_STACK_TRACE;
<             }
<             return stackTrace;
---
>             return asyncGetStackTrace();
1601a2634,2643
>     StackTraceElement[] asyncGetStackTrace() {
>         return StackTraceElement.of((StackTraceElement[])getStackTrace0());
>     }
> 
>     /**
>      * Returns an array of stack trace elements representing the stack dump
>      * of this thread. Returns null if the thread is not alive.
>      */
>     private native Object getStackTrace0();
> 
1603c2645,2646
<      * Returns a map of stack traces for all live threads.
---
>      * Returns a map of stack traces for all live threads. The map does not
>      * include virtual threads.
1641,1644c2684,2685
<             security.checkPermission(
<                 SecurityConstants.GET_STACK_TRACE_PERMISSION);
<             security.checkPermission(
<                 SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
---
>             security.checkPermission(SecurityConstants.GET_STACK_TRACE_PERMISSION);
>             security.checkPermission(SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
1726a2768,2774
>     /**
>      * Return an array of all live threads.
>      */
>     static Thread[] getAllThreads() {
>         return getThreads();
>     }
> 
1740c2788,2790
<         return tid;
---
>         // The 16 most significant bits can be used for tracing
>         // so these bits are excluded using TID_MASK.
>         return tid & ThreadIdentifiers.TID_MASK;
1851,1852c2901,2911
<         // get current thread state
<         return jdk.internal.misc.VM.toThreadState(threadStatus);
---
>         return threadState();
>     }
> 
>     /**
>      * Returns the state of this thread.
>      *
>      * @apiNote For VirtualThread use as getState may be overridden and run
>      * arbitrary code.
>      */
>     State threadState() {
>         return jdk.internal.misc.VM.toThreadState(holder.threadStatus);
1965c3024
<             uncaughtExceptionHandler : group;
---
>             uncaughtExceptionHandler : getThreadGroup();
1984a3044,3047
>         uncaughtExceptionHandler(eh);
>     }
> 
>     private void uncaughtExceptionHandler(UncaughtExceptionHandler eh) {
1990c3053
<      * intended to be called only by the JVM.
---
>      * called when a thread terminates with an exception.
1992c3055
<     private void dispatchUncaughtException(Throwable e) {
---
>     void dispatchUncaughtException(Throwable e) {
2009a3073,3192
>     Thread parentThread;
>     Lifetime lifetime; // the current innermost lifetime (or null)
>     int depth;
>     int parentDepth;
> 
>     /**
>      * TBD
>      *
>      * @return Lifetime
>      */
>     public Lifetime currentLifetime() {
>         return lifetime;
>     }
> 
>     /**
>      * TBD
>      *
>      * @param lt a Lifetime
>      */
>     // V1:
>     public void pushLifetime(Lifetime lt) {
>         assert lt.parent == this.lifetime;
>         this.lifetime = lt;
>     }
> 
>     // V2:
>     Lifetime pushLifetime() {
>         assert this == Thread.currentThread();
>         var newDepth = ++depth;
>         return new Lifetime(this, newDepth);
>     }
> 
>     /**
>      * TBD
>      *
>      * @param lt a Lifetime
>      */
>     public void popLifetime(Lifetime lt) {
>         if (Lifetime.version == Lifetime.Version.V1) {
>             if (this.lifetime != lt)
>                 throw new LifetimeError("lt: [" + lt + "] this: [" + this.currentLifetime() + "]");
>             this.lifetime = lt.parent;
>         } else {
>             assert lt.thread == this;
>             if (this != Thread.currentThread()) throw new LifetimeError();
>             if (lt.depth() != this.depth) throw new LifetimeError();
>             assert depth > parentDepth;
>             depth--;
>         }
>         Scoped.Cache.clearActive();
>     }
> 
>     /**
>      * TBD
>      *
>      * @param lt a Lifetime
>      * @return Previous lifetime
>      */
>     Lifetime unsafeSetLifetime(Lifetime lt) {
>         if (Lifetime.version == Lifetime.Version.V1) {
>             var old = this.lifetime;
>             this.lifetime = lt;
>             return old;
>         } else {
>             assert (!isAlive() && lt.thread == Thread.currentThread())
>                     || this == Thread.currentThread(); // this ensures that depth does not concurrently change here
>             assert depth == parentDepth;
> 
>             var old = new Lifetime(parentThread, parentDepth);
>             this.parentThread = lt.thread;
>             this.parentDepth = lt.depth();
>             this.depth = parentDepth;
>             this.lifetime = lt;
>             return old;
>         }
>     }
> 
>     boolean isActive(Lifetime lt) {
>         if (lt == null || Scoped.Cache.isActive(lt)) return true;
>         if (Lifetime.version == Lifetime.Version.V1) {
>             for (var x = this.lifetime; x != null; x = x.parent) {
>                 if (x == lt) {
>                     Scoped.Cache.setActive(lt);
>                     return true;
>                 }
>             }
>             return false;
>         } else {
>             assert this == Thread.currentThread();
> 
>             // the thread that closes the lifetime must be the thread that owns it
>             // and the thread that sets this thread's parent must be that thread
>             // so either we're on the right thread and we'll see depth = MAX_VALUE due to mem ordering,
>             // or we're on a wrong thread, in which case the parent search will fail; either way, this will fail.
>             if (lt.thread == this) {
>                 boolean result = lt.depth() <= this.depth;
>                 if (Scoped.Cache.CACHE_LIFETIMES) {
>                     if (result) {
>                         Scoped.Cache.setActive(lt);
>                     }
>                 }
>                 return result;
>             }
>             for (Thread t = this; t != null; t = t.parentThread) {
>                 if (Scoped.Cache.CACHE_LIFETIMES) {
>                     if (lt.thread == t.parentThread) {
>                         boolean result = lt.depth() <= t.parentDepth;
>                         if (result) {
>                             Scoped.Cache.setActive(lt);
>                         }
>                         return result;
>                     }
>                 } else {
>                     if (lt.thread == t.parentThread) return lt.depth() <= t.parentDepth;
>                 }
>             }
>             return false;
>         }
>     }
> 
2057a3241,3276
>     private static class VirtualThreads {
>         // Thread group for virtual threads.
>         static final ThreadGroup THREAD_GROUP;
> 
>         // Thread group for kernel threads created by virtual threads
>         static final ThreadGroup THREAD_SUBGROUP;
> 
>         // AccessControlContext that doesn't support any permissions.
>         static final AccessControlContext ACCESS_CONTROL_CONTEXT;
> 
>         static {
>             PrivilegedAction<ThreadGroup> pa = new PrivilegedAction<>() {
>                 @Override
>                 public ThreadGroup run() {
>                     ThreadGroup parent = Thread.currentCarrierThread().getThreadGroup();
>                     for (ThreadGroup p; (p = parent.getParent()) != null; )
>                         parent = p;
>                     return parent;
>                 }
>             };
>             ThreadGroup root = AccessController.doPrivileged(pa);
> 
>             var vgroup = new ThreadGroup(root, "VirtualThreads", NORM_PRIORITY, false);
>             THREAD_GROUP = vgroup;
> 
>             int priority = NORM_PRIORITY;
>             if (System.getSecurityManager() != null) {
>                 priority = MIN_PRIORITY;
>             }
>             THREAD_SUBGROUP = new ThreadGroup(vgroup, "other", priority, false);
> 
>             ACCESS_CONTROL_CONTEXT = new AccessControlContext(new ProtectionDomain[] {
>                 new ProtectionDomain(null, null)
>             });
>         }
>     }
2062,2063c3281
<     // concurrent code, and we can not risk accidental false sharing.
<     // Hence, the fields are isolated with @Contended.
---
>     // concurrent code.
2066d3283
<     @jdk.internal.vm.annotation.Contended("tlr")
2070d3286
<     @jdk.internal.vm.annotation.Contended("tlr")
2074d3289
<     @jdk.internal.vm.annotation.Contended("tlr")
